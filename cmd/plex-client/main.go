package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"runtime"
	"sort"
	"strings"
	"time"

	"github.com/Waddenn/plex-client/internal/auth"
	"github.com/Waddenn/plex-client/internal/cache"
	"github.com/Waddenn/plex-client/internal/config"
	"github.com/Waddenn/plex-client/internal/db"
	"github.com/Waddenn/plex-client/internal/plex"
	"github.com/Waddenn/plex-client/internal/tui"
	tea "github.com/charmbracelet/bubbletea"
)

func main() {
	var (
		baseURLFlag = flag.String("baseurl", "", "Plex server BaseURL")
		tokenFlag   = flag.String("token", "", "Plex Token")
		forceSync   = flag.Bool("force-sync", false, "Force full cache sync")
	)
	flag.Parse()

	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("Error loading config: %v", err)
	}

	// Apply flags to config
	if *baseURLFlag != "" {
		cfg.Plex.BaseURL = *baseURLFlag
	}
	if *tokenFlag != "" {
		cfg.Plex.Token = *tokenFlag
	}

	// Save config if flags were provided
	if *baseURLFlag != "" || *tokenFlag != "" {
		if err := config.Save(cfg); err != nil {
			log.Printf("Warning: failed to save config: %v", err)
		} else {
			dir, _ := config.ConfigDir()
			fmt.Printf("âœ… Configuration saved to %s/config.toml\n", dir)
		}
	}

	// Check for commands
	if len(os.Args) > 1 && os.Args[1] == "login" {
		runLoginFlow(cfg)
	}

	if cfg.Plex.BaseURL == "" || cfg.Plex.Token == "" {
		fmt.Println("âŒ Missing configuration.")
		fmt.Print("Would you like to login to Plex now? [Y/n]: ")

		var response string
		fmt.Scanln(&response) // wait for enter

		if response == "" || response == "y" || response == "Y" {
			// Trigger login flow
			runLoginFlow(cfg)
		} else {
			fmt.Println("Usage: plex-client --baseurl URL --token TOKEN")
			fmt.Println("   or create ~/.config/plex-client/config.toml")
			os.Exit(1)
		}
	}

	d, err := db.Open()
	if err != nil {
		log.Fatalf("Database error: %v", err)
	}
	defer d.Close()

	p := plex.New(cfg.Plex.BaseURL, cfg.Plex.Token, "plex-client-go")

	// Check if we have data
	hasData := false
	var count int
	if err := d.QueryRow("SELECT count(*) FROM films").Scan(&count); err == nil && count > 0 {
		hasData = true
	}
	if !hasData {
		if err := d.QueryRow("SELECT count(*) FROM series").Scan(&count); err == nil && count > 0 {
			hasData = true
		}
	}

	// Use config sync settings
	forceSyncFlag := *forceSync || cfg.Sync.ForceSyncOnStart

	if !hasData || forceSyncFlag {
		fmt.Println("ðŸš€ Syncing library for the first time... This might take a while.")
		if err := cache.Sync(p, d, forceSyncFlag); err != nil {
			log.Printf("Sync error: %v", err)
		}
	} else if cfg.Sync.AutoSync {
		// Background sync
		go func() {
			if err := cache.Sync(p, d, false); err != nil {
				log.Printf("Background sync error: %v", err)
			}
		}()
	}

	m := tui.NewModel(d, cfg, p)
	if _, err := tea.NewProgram(&m, tea.WithAltScreen()).Run(); err != nil {
		fmt.Printf("Error running TUI: %v\n", err)
		os.Exit(1)
	}
}

func runLoginFlow(cfg *config.Config) {
	clientID := cfg.Plex.ClientIdentifier
	if clientID == "" {
		// Should be auto-generated by config.Load(), but safety check
		clientID = "plex-client-go-cli-fallback"
	}

	fmt.Printf("ðŸ†” Using Client ID: %s\n", clientID)
	authClient := auth.NewAuthClient(clientID, "Plex Client CLI", "0.1.0")

	fmt.Println("ðŸ”„ Requesting PIN from Plex...")
	pin, authLink, err := authClient.GetPin()
	if err != nil {
		log.Fatalf("Error getting PIN: %v", err)
	}

	fmt.Printf("\nðŸ”— Please open this URL to login:\n%s\n", authLink)

	// Auto-open browser
	openBrowser(authLink)

	fmt.Printf("\n(Waiting for authorization...)\n")

	// Poll for token
	ticker := time.NewTicker(2 * time.Second)
	defer ticker.Stop()
	timeout := time.After(2 * time.Minute)

	for {
		select {
		case <-timeout:
			fmt.Println("âŒ Timed out waiting for login.")
			os.Exit(1)
		case <-ticker.C:
			p, err := authClient.CheckPin(pin.ID)
			if err != nil {
				continue
			}
			if p.AuthToken != "" {
				fmt.Println("âœ… Login successful!")
				cfg.Plex.Token = p.AuthToken

				fmt.Println("ðŸ” Searching for servers...")
				resources, err := authClient.GetResources(p.AuthToken)
				if err != nil {
					log.Printf("Warning: failed to get resources: %v", err)
				} else {
					// Find first server
					for _, res := range resources {
						if res.Provides == "server" || res.Product == "Plex Media Server" {
							fmt.Printf("found server: %s\n", res.Name)

							if len(res.Connections) > 0 {
								// Sort connections: Remote > Local (Non-Docker) > Docker
								sort.Slice(res.Connections, func(i, j int) bool {
									return getConnectionScore(res.Connections[i]) > getConnectionScore(res.Connections[j])
								})

								// Auto-select the best connection (first one after sorting)
								selectedConn := res.Connections[0]
								cfg.Plex.BaseURL = selectedConn.Uri

								loc := "Remote"
								if selectedConn.Local {
									loc = "Local"
								}
								fmt.Printf("âœ… Automatically selected %s connection: %s (%s)\n", loc, selectedConn.Uri, selectedConn.Address)

								fmt.Printf("ðŸ”— Connected to %s (%s)\n", res.Name, cfg.Plex.BaseURL)
								break
							}
						}
					}
				}

				if err := config.Save(cfg); err != nil {
					log.Fatalf("Error saving config: %v", err)
				}
				dir, _ := config.ConfigDir()
				fmt.Printf("Configuration saved to %s/config.toml\n", dir)

				// Continue to application instead of exiting
				return
			}
		}
	}
}

func openBrowser(url string) {
	var err error
	switch runtime.GOOS {
	case "linux":
		err = exec.Command("xdg-open", url).Start()
	case "windows":
		err = exec.Command("rundll32", "url.dll,FileProtocolHandler", url).Start()
	case "darwin":
		err = exec.Command("open", url).Start()
	default:
		// Try generic xdg-open for other unix-likes
		err = exec.Command("xdg-open", url).Start()
	}
	if err != nil {
		// Non-fatal, just log
		// fmt.Printf("Could not open browser: %v\n", err)
	}
}

func getConnectionScore(conn auth.PlexConnection) int {
	if !conn.Local {
		return 3 // Remote is preferred as per user request
	}
	// Local connections
	if strings.HasPrefix(conn.Address, "172.") {
		return 1 // Likely Docker/Container, lowest priority
	}
	return 2 // Standard Local LAN
}
